@doc raw"""
Nonlocal term coming from norm-conserving pseudopotentials in Kleinmann-Bylander form.
```math
\text{Energy} =
    ∑_a ∑_{ij} ∑_{n} f_n \braket{ψ_n}{{\rm proj}_{ai}} D_{ij} \braket{{\rm proj}_{aj}}{ψ_n}.
```
"""

# Clebsch-Gordan coefficients for coupling l and s=1/2 to j
# Returns (c_up, c_dn) such that |ljm> = c_up |l, m-1/2, ↑> + c_dn |l, m+1/2, ↓>
function get_spinor_coeffs(l, j, m)
    # Case j = l + 1/2
    if abs(j - (l + 0.5)) < 1e-4
        c_up = sqrt((l + m + 0.5) / (2l + 1))
        c_dn = sqrt((l - m + 0.5) / (2l + 1))
        return (c_up, c_dn)
    # Case j = l - 1/2
    elseif abs(j - (l - 0.5)) < 1e-4 && l > 0
        c_up = -sqrt((l - m + 0.5) / (2l + 1))
        c_dn =  sqrt((l + m + 0.5) / (2l + 1))
        return (c_up, c_dn)
    else
        return (0.0, 0.0)
    end
end

struct AtomicNonlocal end
function (::AtomicNonlocal)(basis::PlaneWaveBasis{T}) where {T}
    model = basis.model

    # keep only pseudopotential atoms and positions
    psp_groups = [group for group in model.atom_groups
                  if model.atoms[first(group)] isa ElementPsp]
    psps          = [model.atoms[first(group)].psp for group in psp_groups]
    psp_positions = [model.positions[group] for group in psp_groups]

    isempty(psp_groups) && return TermNoop()
    ops = map(basis.kpoints) do kpt
        P = build_projection_vectors(basis, kpt, psps, psp_positions)
        # CHANGED: Pass `basis` instead of just `T` to access model.spin_polarization
        D = build_projection_coefficients(basis, psps, psp_positions) 
        NonlocalOperator(basis, kpt, P, to_device(basis.architecture, D))
    end
    TermAtomicNonlocal(ops)
end

struct TermAtomicNonlocal <: TermLinear
    ops::Vector{NonlocalOperator}
end

@timing "ene_ops: nonlocal" function ene_ops(term::TermAtomicNonlocal,
                                             basis::PlaneWaveBasis{T},
                                             ψ, occupation; kwargs...) where {T}
    if isnothing(ψ) || isnothing(occupation)
        return (; E=T(Inf), term.ops)
    end

    E = zero(T)
    for (ik, ψk) in enumerate(ψ)
        Pψk = term.ops[ik].P' * ψk  # nproj x nband
        band_enes = dropdims(sum(real.(conj.(Pψk) .* (term.ops[ik].D * Pψk)), dims=1), dims=1)
        E += basis.kweights[ik] * sum(band_enes .* occupation[ik])
    end
    E = mpi_sum(E, basis.comm_kpts)

    (; E, term.ops)
end

@timing "forces: nonlocal" function compute_forces(::TermAtomicNonlocal,
                                                   basis::PlaneWaveBasis{TT}, ψ, occupation;
                                                   kwargs...) where {TT}
    T = promote_type(TT, real(eltype(ψ[1])))
    model = basis.model
    unit_cell_volume = model.unit_cell_volume
    psp_groups = [group for group in model.atom_groups
                  if model.atoms[first(group)] isa ElementPsp]

    # Early return if no pseudopotential atoms.
    isempty(psp_groups) && return nothing

    # Energy terms are of the form <ψ, P C P' ψ>, where
    #   P(G) = form_factor(G) * structure_factor(G).
    forces = Vec3{T}[zero(Vec3{T}) for _ = 1:length(model.positions)]

    for group in psp_groups
        element = model.atoms[first(group)]

        # CHANGED: === FIX: Pass 'basis' instead of 'T' here ===
        C = to_device(basis.architecture, build_projection_coefficients(basis, element.psp))
        # =============================================

        for (ik, kpt) in enumerate(basis.kpoints)
            # We compute the forces from the irreductible BZ; they are symmetrized later.
            G_plus_k_cart = to_cpu(Gplusk_vectors_cart(basis, kpt))
            G_plus_k = Gplusk_vectors(basis, kpt)
            form_factors = to_device(basis.architecture,
                                     build_projector_form_factors(element.psp, G_plus_k_cart))

            # Pre-allocation of large arrays
            δHψk  = similar(ψ[ik])
            P     = similar(form_factors)
            dPdR  = similar(form_factors)
            twoπp = similar(form_factors, length(G_plus_k))
            structure_factors = similar(form_factors, length(G_plus_k))

            for idx in group
                r = model.positions[idx]
                map!(p -> cis2pi(-dot(p, r)), structure_factors, G_plus_k)
                P .= structure_factors .* form_factors ./ sqrt(unit_cell_volume)

                forces[idx] += map(1:3) do α
                    map!(p -> -2π*im*p[α], twoπp, G_plus_k)
                    dPdR .= twoπp .* P
                    mul!(δHψk, P, C * (dPdR' * ψ[ik]))
                    -basis.kweights[ik]*sum(occupation[ik] .* 2vec(real(columnwise_dots(ψ[ik], δHψk))))
                end  # α
            end  # r
        end  # kpt
    end  # group

    mpi_sum!(forces, basis.comm_kpts)
    symmetrize_forces(basis, forces)
end

# TODO possibly move over to pseudo/NormConservingPsp.jl ?
# Build projection coefficients for a atoms array generated by term_nonlocal
# The ordering of the projector indices is (A,l,m,i), where A is running over all
# atoms, l, m are AM quantum numbers and i is running over all projectors for a
# given l. The matrix is block-diagonal with non-zeros only if A, l and m agree.
# Wrapper that dispatches based on Basis
# CHANGED: changed in order to enable the SOC and non-collinear calculation
function build_projection_coefficients(basis::PlaneWaveBasis{T}, psps, psp_positions) where {T}
    # Calculate total size
    n_proj_scalar = count_n_proj(psps, psp_positions)
    is_soc = (basis.model.spin_polarization == :full)
    n_proj = is_soc ? 2 * n_proj_scalar : n_proj_scalar

    proj_coeffs = zeros(T, n_proj, n_proj)

    count = 0
    for (psp, positions) in zip(psps, psp_positions), _ in positions
        # Get block for this atom
        D_atom = build_projection_coefficients(basis, psp)
        n_p = size(D_atom, 1)
        
        block = count+1:count+n_p
        proj_coeffs[block, block] = D_atom
        count += n_p
    end
    @assert count == n_proj

    proj_coeffs
end

# Builds the projection coefficient matrix for a single atom
# The ordering of the projector indices is (l,m,i), where l, m are the
# AM quantum numbers and i is running over all projectors for a given l.
# The matrix is block-diagonal with non-zeros only if l and m agree.
# Atom-specific builder

# CHANGED: changed in order to enable the SOC and non-collinear calculation
# Atom-specific builder
function build_projection_coefficients(basis::PlaneWaveBasis{T}, psp::NormConservingPsp) where {T}
    is_soc = (basis.model.spin_polarization == :full)
    
    if is_soc
        # === SOC Construction ===
        n_proj_soc = sum(l -> count_n_proj_radial(psp, l) * 2 * (2l+1), 0:psp.lmax; init=0)
        
        proj_coeffs = zeros(T, n_proj_soc, n_proj_soc)
        count = 0
        
        for l = 0:psp.lmax
            n_rad = count_n_proj_radial(psp, l)
            soc_data = get_soc_coupling(psp, l) 
            
            # Fallback scalar if no SOC data
            h_scalar = psp.h[l+1] 
            
            for i = 1:n_rad
                # Relativistic loop: j = l-1/2, l+1/2
                js = (l == 0) ? [0.5] : [l - 0.5, l + 0.5]
                
                for (j_idx, j) in enumerate(js)
                    # Determine energy D_ij for this state
                    h_val = zero(T)
                    
                    if !isnothing(soc_data)
                        target_vec = nothing
                        
                        if l == 0
                            # For l=0, j=1/2. Check index 1 or 2.
                            # FIX: Added '&& length(...) >= i' to prevent BoundsError
                            if length(soc_data) >= 1 && length(soc_data[1]) >= i
                                target_vec = soc_data[1]
                            elseif length(soc_data) >= 2 && length(soc_data[2]) >= i
                                target_vec = soc_data[2]
                            end
                        else
                            # For l > 0
                            # FIX: Added '&& length(...) >= i'
                            if length(soc_data) >= j_idx && length(soc_data[j_idx]) >= i
                                target_vec = soc_data[j_idx]
                            end
                        end
                        
                        if !isnothing(target_vec)
                            h_val = target_vec[i]
                        else
                            # Fallback to scalar if SOC data is missing/short for this radial index
                            h_val = h_scalar[i,i]
                        end
                    else
                        # Fallback if no SOC data at all
                        h_val = h_scalar[i,i]
                    end
                    
                    # Fill diagonal for all mj (-j to j)
                    deg = Int(2*j + 1)
                    for _ in 1:deg
                        count += 1
                        proj_coeffs[count, count] = h_val
                    end
                end
            end
        end
        return proj_coeffs

    else
        # === SCALAR Construction (Original Logic) ===
        n_proj = count_n_proj(psp)
        proj_coeffs = zeros(T, n_proj, n_proj)
        count = 0
        for l = 0:psp.lmax, _ = -l:l
            n_proj_l = count_n_proj_radial(psp, l)
            range = count .+ (1:n_proj_l)
            proj_coeffs[range, range] = psp.h[l + 1]
            count += n_proj_l
        end
        return proj_coeffs
    end
end

@doc raw"""
Build projection vectors for a atoms array generated by term_nonlocal

```math
\begin{aligned}
H_{\rm at}  &= \sum_{ij} C_{ij} \ket{{\rm proj}_i} \bra{{\rm proj}_j} \\
H_{\rm per} &= \sum_R \sum_{ij} C_{ij} \ket{{\rm proj}_i(x-R)} \bra{{\rm proj}_j(x-R)}
\end{aligned}
```

```math
\begin{aligned}
\braket{e_k(G') \middle| H_{\rm per}}{e_k(G)}
        &= \ldots \\
        &= \frac{1}{Ω} \sum_{ij} C_{ij} \widehat{\rm proj}_i(k+G') \widehat{\rm proj}_j^*(k+G),
\end{aligned}
```

where ``\widehat{\rm proj}_i(p) = ∫_{ℝ^3} {\rm proj}_i(r) e^{-ip·r} dr``.

We store ``\frac{1}{\sqrt Ω} \widehat{\rm proj}_i(k+G)`` in `proj_vectors`.
"""
function build_projection_vectors(basis::PlaneWaveBasis{T}, kpt::Kpoint,
                                  psps::AbstractVector{<: NormConservingPsp},
                                  psp_positions) where {T}
    unit_cell_volume = basis.model.unit_cell_volume
    n_proj_scalar = count_n_proj(psps, psp_positions)
    n_G    = length(G_vectors(basis, kpt))
    
    # SOC Check
    is_soc = (basis.model.spin_polarization == :full)
    # If SOC, we have 2x the projectors (spin-orbitals) and vectors are 2x long (spinors)
    n_proj = is_soc ? 2 * n_proj_scalar : n_proj_scalar
    vec_len = is_soc ? 2 * n_G : n_G

    proj_vectors = zeros(Complex{eltype(psp_positions[1][1])}, vec_len, n_proj)
    G_plus_k = to_cpu(Gplusk_vectors(basis, kpt))

    # Helpers for SOC indexing
    # We need to map standard (l,m) form factors to relativistic (l,j,mj)
    
    offset = 0 
    for (psp, positions) in zip(psps, psp_positions)
        # Compute position-independent form factors (scalar radial part)
        G_plus_k_cart = to_cpu(Gplusk_vectors_cart(basis, kpt))
        form_factors = build_projector_form_factors(psp, G_plus_k_cart)

        for r in positions
            structure_factors = map(p -> cis2pi(-dot(p, r)), G_plus_k)
            
            # === SOC BRANCH ===
            if is_soc
                current_proj_idx = 0
                for l = 0:psp.lmax
                    n_proj_l = count_n_proj_radial(psp, l)
                    for i = 1:n_proj_l
                        # Iterate Relativistic j states: l-1/2 and l+1/2
                        js = (l == 0) ? [0.5] : [l - 0.5, l + 0.5]
                        
                        for j in js
                            # Iterate mj from -j to j
                            for mj = -j:1.0:j
                                (c_up, c_dn) = get_spinor_coeffs(l, j, mj)
                                
                                # We need to grab the scalar form factor for m_orb = mj +/- 0.5
                                # build_projector_form_factors packs them as:
                                # Offset(l) + Offset(i) + (m + l + 1)
                                
                                # Helper to get scalar column index
                                function get_ff_col(m_orb)
                                    if abs(m_orb) > l; return 0; end
                                    base_l = sum(x -> count_n_proj(psp, x), 0:l-1; init=0)
                                    base_i = (i-1) * (2l+1)
                                    return base_l + base_i + (Int(m_orb) + l + 1)
                                end

                                col_idx = offset + current_proj_idx + 1

                                # --- Construct Up Component ---
                                m_up = mj - 0.5
                                idx_up = get_ff_col(m_up)
                                if idx_up > 0
                                    @views proj_vectors[1:n_G, col_idx] .+= 
                                        c_up .* structure_factors .* form_factors[:, idx_up] ./ sqrt(unit_cell_volume)
                                end

                                # --- Construct Down Component ---
                                m_dn = mj + 0.5
                                idx_dn = get_ff_col(m_dn)
                                if idx_dn > 0
                                    @views proj_vectors[n_G+1:end, col_idx] .+= 
                                        c_dn .* structure_factors .* form_factors[:, idx_dn] ./ sqrt(unit_cell_volume)
                                end
                                
                                current_proj_idx += 1
                            end
                        end
                    end
                end
                offset += current_proj_idx

            else
                # === SCALAR BRANCH ===
                @views for iproj = 1:count_n_proj(psp)
                    proj_vectors[:, offset+iproj] .=
                        structure_factors .* form_factors[:, iproj] ./ sqrt(unit_cell_volume)
                end
                offset += count_n_proj(psp)
            end
        end
    end
    
    to_device(basis.architecture, proj_vectors)
end

"""
Build form factors (Fourier transforms of projectors) for all orbitals of an atom centered at 0.
"""
function build_projector_form_factors(psp::NormConservingPsp,
                                      G_plus_k::AbstractVector{Vec3{TT}}) where {TT}
    G_plus_ks = [G_plus_k]

    n_proj = count_n_proj(psp)
    form_factors = zeros(Complex{TT}, length(G_plus_k), n_proj)
    for l = 0:psp.lmax, 
        n_proj_l = count_n_proj_radial(psp, l)
        offset = sum(x -> count_n_proj(psp, x), 0:l-1; init=0) .+ 
                 n_proj_l .* (collect(1:2l+1) .- 1) # offset about m for a given l 
        for i = 1:n_proj_l
            proj_li(p) = eval_psp_projector_fourier(psp, i, l, p)
            form_factors_li = build_form_factors(proj_li, l, G_plus_ks)
            @views form_factors[:, offset.+i] = form_factors_li[1]
        end
    end

    form_factors
end

"""
Build Fourier transform factors of an atomic function centered at 0 for a given l.
"""
function build_form_factors(fun::Function, l::Int,
                            G_plus_ks::AbstractVector{<:AbstractVector{Vec3{TT}}}) where {TT}
    # TODO this function can be generally useful, should refactor to a separate file eventually
    T = real(TT)

    # Pre-compute the radial parts of the non-local atomic functions at unique |p| to speed up
    # the form factor calculation (by a lot). Using a hash map gives O(1) lookup.

    radials = IdDict{T,T}()  # IdDict for Dual compatibility
    for G_plus_k in G_plus_ks
        for p in G_plus_k
            p_norm = norm(p)
            if !haskey(radials, p_norm)
                radials_p = fun(p_norm)
                radials[p_norm] = radials_p
            end
        end
    end

    form_factors = Vector{Matrix{Complex{T}}}(undef, length(G_plus_ks))
    for (ik, G_plus_k) in enumerate(G_plus_ks)
        form_factors_ik = Matrix{Complex{T}}(undef, length(G_plus_k), 2l + 1)
        for (ip, p) in enumerate(G_plus_k)
            radials_p = radials[norm(p)]
            for m = -l:l
                # see "Fourier transforms of centered functions" in the docs for the formula
                angular = (-im)^l * ylm_real(l, m, p)
                form_factors_ik[ip, m+l+1] = radials_p * angular
            end
        end
        form_factors[ik] = form_factors_ik
    end

    form_factors
end

# Helpers for phonon computations.
function build_projection_coefficients(basis::PlaneWaveBasis{T}, psp_groups) where {T}
    psps          = [basis.model.atoms[first(group)].psp for group in psp_groups]
    psp_positions = [basis.model.positions[group] for group in psp_groups]
    
    # CHANGED: === FIX: Pass 'basis' instead of 'T' ===
    build_projection_coefficients(basis, psps, psp_positions)
end
function build_projection_vectors(basis::PlaneWaveBasis, kpt::Kpoint,
                                  psp_groups::AbstractVector{<: AbstractVector{<: Int}},
                                  positions)
    psps          = [basis.model.atoms[first(group)].psp for group in psp_groups]
    psp_positions = [positions[group] for group in psp_groups]
    build_projection_vectors(basis, kpt, psps, psp_positions)
end
function PDPψk(basis, positions, psp_groups, kpt, kpt_minus_q, ψk)
    D = build_projection_coefficients(basis, psp_groups)
    P = build_projection_vectors(basis, kpt, psp_groups, positions)
    P_minus_q = build_projection_vectors(basis, kpt_minus_q, psp_groups, positions)
    P * (D * P_minus_q' * ψk)
end

function compute_dynmat_δH(::TermAtomicNonlocal, basis::PlaneWaveBasis{T}, ψ, occupation,
                           δψ, δoccupation, q) where {T}
    S = complex(T)
    model = basis.model
    psp_groups = [group for group in model.atom_groups
                  if model.atoms[first(group)] isa ElementPsp]

    # Early return if no pseudopotential atoms.
    isempty(psp_groups) && return nothing

    δforces = [zero(Vec3{S}) for _ = 1:length(model.positions)]
    for group in psp_groups
        δψ_plus_q = transfer_blochwave_equivalent_to_actual(basis, δψ, q)
        for (ik, kpt) in enumerate(basis.kpoints)
            ψk = ψ[ik]
            δψk_plus_q = δψ_plus_q[ik].ψk
            kpt_plus_q = δψ_plus_q[ik].kpt

            for idx in group
                δforces[idx] += map(1:3) do α
                    δHψk = derivative_wrt_αs(model.positions, α, idx) do positions_αs
                        PDPψk(basis, positions_αs, psp_groups, kpt_plus_q, kpt, ψ[ik])
                    end
                    δHψk_plus_q = derivative_wrt_αs(model.positions, α, idx) do positions_αs
                        PDPψk(basis, positions_αs, psp_groups, kpt, kpt, ψ[ik])
                    end
                    -basis.kweights[ik] * sum(2occupation[ik] .* vec(columnwise_dots(δψk_plus_q, δHψk)) +
                                              δoccupation[ik] .* 2vec(real(columnwise_dots(ψk, δHψk_plus_q))))
                end
            end
        end
    end

    mpi_sum!(δforces, basis.comm_kpts)
end

@views function compute_dynmat(term::TermAtomicNonlocal, basis::PlaneWaveBasis{T}, ψ,
                               occupation; δψs, δoccupations, q=zero(Vec3{T}),
                               kwargs...) where {T}
    S = complex(T)
    model = basis.model
    positions = model.positions
    n_atoms = length(positions)
    n_dim = model.n_dim

    # Two contributions: dynmat_δH and dynmat_δ²H.

    # dynmat_δH
    dynmat_δH = zeros(S, 3, n_atoms, 3, n_atoms)
    for s = 1:n_atoms, α = 1:n_dim
        dynmat_δH[:, :, α, s] .-= stack(
            compute_dynmat_δH(term, basis, ψ, occupation, δψs[α, s], δoccupations[α, s], q)
        )
    end

    psp_groups = [group for group in model.atom_groups
                  if model.atoms[first(group)] isa ElementPsp]
    # Early return if no pseudopotential atoms.
    isempty(psp_groups) && return dynmat_δH

    # dynmat_δ²H
    dynmat_δ²H = zeros(S, 3, n_atoms, 3, n_atoms)
    δ²Hψ = zero.(ψ)
    for s = 1:n_atoms, α = 1:n_dim, β = 1:n_dim  # zero if s ≠ t
        for (ik, kpt) in enumerate(basis.kpoints)
            δ²Hψ[ik] = derivative_wrt_αs(basis.model.positions, β, s) do positions_βs
                derivative_wrt_αs(positions_βs, α, s) do positions_βsαs
                    PDPψk(basis, positions_βsαs, psp_groups, kpt, kpt, ψ[ik])
                end
            end
            dynmat_δ²H[β, s, α, s] += sum(occupation[ik][n] * basis.kweights[ik] *
                                              dot(ψ[ik][:, n], δ²Hψ[ik][:, n])
                                          for n=1:size(ψ[ik], 2))
        end
    end

    dynmat_δH + dynmat_δ²H
end

# δH is the Fourier transform perturbation of the nonlocal potential due to a position
# displacement e^{iq·r} of the α coordinate of atom s.
function compute_δHψ_αs(::TermAtomicNonlocal, basis::PlaneWaveBasis{T}, ψ, α, s, q) where {T}
    model = basis.model
    psp_groups = [group for group in model.atom_groups
                  if model.atoms[first(group)] isa ElementPsp]

    ψ_minus_q = transfer_blochwave_equivalent_to_actual(basis, ψ, -q)
    map(enumerate(basis.kpoints)) do (ik, kpt)
        derivative_wrt_αs(model.positions, α, s) do positions_αs
            PDPψk(basis, positions_αs, psp_groups, kpt, ψ_minus_q[ik].kpt, ψ_minus_q[ik].ψk)
        end
    end
end
